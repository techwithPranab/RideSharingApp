/**
 * Payment service for handling Razorpay integration
 * Manages payment creation, processing, and webhooks
 */

import Razorpay from 'razorpay';
import crypto from 'crypto';
import { Payment, IPayment, PaymentType, PaymentStatus, PaymentMethod } from '../models/Payment';
import { Ride, RideStatus } from '../models/Ride';
import { User } from '../models/User';
import { emailService } from './emailService';
import { logger } from '../utils/logger';

export interface PaymentRequest {
  amount: number;
  currency?: string;
  method: PaymentMethod;
  description?: string;
  rideId?: string;
  payerId: string;
  payeeId?: string;
}

export interface RazorpayOrder {
  id: string;
  amount: number;
  currency: string;
  receipt: string;
  status: string;
}

export interface PaymentVerificationData {
  razorpay_order_id: string;
  razorpay_payment_id: string;
  razorpay_signature: string;
}

export class PaymentService {
  private static razorpay: Razorpay | null = null;

  static {
    // Initialize Razorpay only if valid keys are provided
    const keyId = process.env.RAZORPAY_KEY_ID;
    const keySecret = process.env.RAZORPAY_KEY_SECRET;
    
    if (keyId && keySecret && keyId !== 'rzp_test_demo_key' && keySecret !== 'demo_secret_key') {
      this.razorpay = new Razorpay({
        key_id: keyId,
        key_secret: keySecret
      });
    }
  }

  /**
   * Create a Razorpay order
   */
  static async createOrder(paymentRequest: PaymentRequest): Promise<RazorpayOrder> {
    try {
      if (!this.razorpay) {
        throw new Error('Payment gateway not configured. Please configure Razorpay keys.');
      }

      const { amount, currency = 'INR', description } = paymentRequest;

      // Convert amount to paisa (Razorpay expects amount in smallest currency unit)
      const amountInPaisa = Math.round(amount * 100);

      const options = {
        amount: amountInPaisa,
        currency,
        receipt: `receipt_${Date.now()}`,
        notes: {
          description: description || 'Ride payment'
        }
      };

      const order = await this.razorpay!.orders.create(options);

      logger.info(`Razorpay order created: ${order.id}`);

      return {
        id: order.id,
        amount: Number(order.amount),
        currency: order.currency,
        receipt: order.receipt || '',
        status: order.status
      };
    } catch (error) {
      logger.error('Error creating Razorpay order:', error);
      throw new Error('Failed to create payment order');
    }
  }

  /**
   * Create a payment record in database
   */
  static async createPaymentRecord(
    paymentRequest: PaymentRequest,
    razorpayOrderId?: string
  ): Promise<IPayment> {
    try {
      const {
        amount,
        currency = 'INR',
        method,
        description,
        rideId,
        payerId,
        payeeId
      } = paymentRequest;

      // Determine payment type
      let type = PaymentType.RIDE_PAYMENT;
      if (!rideId) {
        type = PaymentType.INCENTIVE;
      }

      const payment = new Payment({
        paymentId: '', // Will be generated by pre-save middleware
        type,
        rideId,
        payerId,
        payeeId,
        amount,
        currency,
        method,
        gatewayOrderId: razorpayOrderId,
        description: description || 'Payment for ride service'
      });

      await payment.save();
      return payment;
    } catch (error) {
      logger.error('Error creating payment record:', error);
      throw new Error('Failed to create payment record');
    }
  }

  /**
   * Process ride payment
   */
  static async processRidePayment(
    rideId: string,
    payerId: string,
    paymentMethod: PaymentMethod
  ): Promise<{ payment: IPayment; order: RazorpayOrder }> {
    try {
      // Find the ride
      const ride = await Ride.findById(rideId)
        .populate('passengers.userId')
        .populate('driverId');

      if (!ride) {
        throw new Error('Ride not found');
      }

      if (ride.status !== RideStatus.COMPLETED) {
        throw new Error('Ride must be completed before payment');
      }

      // Check if payment already exists
      const existingPayment = await Payment.findOne({
        rideId,
        payerId,
        status: { $in: [PaymentStatus.PENDING, PaymentStatus.PROCESSING, PaymentStatus.COMPLETED] }
      });

      if (existingPayment) {
        throw new Error('Payment already exists for this ride');
      }

      // Create payment request
      const paymentRequest: PaymentRequest = {
        amount: ride.totalFare,
        currency: 'INR',
        method: paymentMethod,
        description: `Payment for ride ${ride.rideId}`,
        rideId,
        payerId,
        payeeId: ride.driverId._id.toString()
      };

      // Create Razorpay order
      const order = await this.createOrder(paymentRequest);

      // Create payment record
      const payment = await this.createPaymentRecord(paymentRequest, order.id);

      return { payment, order };
    } catch (error) {
      logger.error('Error processing ride payment:', error);
      throw error;
    }
  }

  /**
   * Verify Razorpay payment
   */
  static async verifyPayment(verificationData: PaymentVerificationData): Promise<boolean> {
    try {
      const { razorpay_order_id, razorpay_payment_id, razorpay_signature } = verificationData;

      // Create expected signature
      const sign = razorpay_order_id + '|' + razorpay_payment_id;
      const expectedSign = crypto
        .createHmac('sha256', process.env.RAZORPAY_KEY_SECRET || '')
        .update(sign.toString())
        .digest('hex');

      // Verify signature
      if (razorpay_signature === expectedSign) {
        logger.info(`Payment verification successful: ${razorpay_payment_id}`);
        return true;
      } else {
        logger.error(`Payment verification failed: ${razorpay_payment_id}`);
        return false;
      }
    } catch (error) {
      logger.error('Error verifying payment:', error);
      return false;
    }
  }

  /**
   * Handle successful payment
   */
  static async handlePaymentSuccess(
    paymentId: string,
    gatewayPaymentId: string,
    gatewaySignature: string
  ): Promise<IPayment> {
    try {
      // Find payment record
      const payment = await Payment.findOne({ gatewayOrderId: paymentId });

      if (!payment) {
        throw new Error('Payment record not found');
      }

      // Update payment with gateway details
      payment.gatewayTransactionId = gatewayPaymentId;
      payment.gatewaySignature = gatewaySignature;

      // Update payment status
      await payment.updateStatus(PaymentStatus.COMPLETED, {
        gatewayPaymentId,
        gatewaySignature
      });

      // If this is a ride payment, update ride payment status
      if (payment.rideId) {
        await Ride.findByIdAndUpdate(payment.rideId, {
          paymentStatus: PaymentStatus.COMPLETED,
          'passengers.$[elem].paymentStatus': PaymentStatus.COMPLETED
        }, {
          arrayFilters: [{ 'elem.userId': payment.payerId }]
        });
      }

      // Send payment confirmation email
      try {
        const payer = await User.findById(payment.payerId);
        if (payer && payer.email) {
          const paymentDetails = {
            paymentId: payment.paymentId,
            amount: payment.amount,
            method: payment.method,
            completedAt: payment.completedAt
          };

          await emailService.sendPaymentConfirmation(
            payer.email,
            `${payer.firstName} ${payer.lastName}`,
            paymentDetails
          );
          logger.info(`Payment confirmation email sent to ${payer.email}`);
        }
      } catch (emailError) {
        logger.error('Failed to send payment confirmation email:', emailError);
        // Don't fail the payment if email fails
      }

      logger.info(`Payment completed successfully: ${payment.paymentId}`);
      return payment;
    } catch (error) {
      logger.error('Error handling payment success:', error);
      throw error;
    }
  }

  /**
   * Handle failed payment
   */
  static async handlePaymentFailure(
    paymentId: string,
    failureReason: string
  ): Promise<IPayment> {
    try {
      // Find payment record
      const payment = await Payment.findOne({ gatewayOrderId: paymentId });

      if (!payment) {
        throw new Error('Payment record not found');
      }

      // Update payment status to failed
      await payment.updateStatus(PaymentStatus.FAILED, {
        failureReason
      });

      // If this is a ride payment, update ride payment status
      if (payment.rideId) {
        await Ride.findByIdAndUpdate(payment.rideId, {
          paymentStatus: PaymentStatus.FAILED,
          'passengers.$[elem].paymentStatus': PaymentStatus.FAILED
        }, {
          arrayFilters: [{ 'elem.userId': payment.payerId }]
        });
      }

      logger.info(`Payment failed: ${payment.paymentId}, reason: ${failureReason}`);
      return payment;
    } catch (error) {
      logger.error('Error handling payment failure:', error);
      throw error;
    }
  }

  /**
   * Process refund
   */
  static async processRefund(
    paymentId: string,
    refundAmount?: number
  ): Promise<IPayment> {
    try {
      // Find original payment
      const originalPayment = await Payment.findOne({ paymentId });

      if (!originalPayment) {
        throw new Error('Payment not found');
      }

      if (originalPayment.status !== PaymentStatus.COMPLETED) {
        throw new Error('Can only refund completed payments');
      }

      if (!originalPayment.gatewayTransactionId) {
        throw new Error('Payment transaction ID not found');
      }

      // Process refund through Razorpay
      if (!this.razorpay) {
        throw new Error('Payment gateway not configured. Please configure Razorpay keys.');
      }

      const refundOptions: any = {
        payment_id: originalPayment.gatewayTransactionId
      };

      if (refundAmount) {
        refundOptions.amount = Math.round(refundAmount * 100); // Amount in paisa
      }

      await this.razorpay!.payments.refund(
        originalPayment.gatewayTransactionId,
        refundOptions
      );

      // Create refund payment record
      const refund = await originalPayment.processRefund(refundAmount);

      logger.info(`Refund processed: ${refund.paymentId} for payment ${paymentId}`);
      return refund;
    } catch (error) {
      logger.error('Error processing refund:', error);
      throw new Error('Failed to process refund');
    }
  }

  /**
   * Get payment details
   */
  static async getPaymentDetails(paymentId: string, userId: string): Promise<IPayment | null> {
    try {
      const payment = await Payment.findOne({
        paymentId,
        $or: [
          { payerId: userId },
          { payeeId: userId }
        ]
      })
      .populate('rideId', 'rideId status totalFare')
      .populate('payerId', 'firstName lastName')
      .populate('payeeId', 'firstName lastName');

      return payment;
    } catch (error) {
      logger.error('Error getting payment details:', error);
      throw error;
    }
  }

  /**
   * Handle Razorpay webhook
   */
  static async handleWebhook(webhookData: any, signature: string): Promise<void> {
    try {
      // Verify webhook signature
      const expectedSignature = crypto
        .createHmac('sha256', process.env.RAZORPAY_WEBHOOK_SECRET || '')
        .update(JSON.stringify(webhookData))
        .digest('hex');

      if (signature !== expectedSignature) {
        throw new Error('Invalid webhook signature');
      }

      const { event, payload } = webhookData;

      switch (event) {
        case 'payment.captured':
          await this.handlePaymentSuccess(
            payload.payment.entity.order_id,
            payload.payment.entity.id,
            payload.payment.entity.signature || ''
          );
          break;

        case 'payment.failed':
          await this.handlePaymentFailure(
            payload.payment.entity.order_id,
            payload.payment.entity.error_description || 'Payment failed'
          );
          break;

        case 'refund.processed':
          // Handle refund processing if needed
          logger.info(`Refund processed: ${payload.refund.entity.id}`);
          break;

        default:
          logger.info(`Unhandled webhook event: ${event}`);
      }
    } catch (error) {
      logger.error('Error handling webhook:', error);
      throw error;
    }
  }

  /**
   * Calculate split payment for pooled rides
   */
  static calculateSplitFare(
    totalFare: number,
    passengerCount: number,
    platformCommission: number = 0.15
  ): { passengerAmount: number; driverEarnings: number; platformFee: number } {
    const platformFee = totalFare * platformCommission;
    const amountAfterCommission = totalFare - platformFee;
    const passengerAmount = Math.round((amountAfterCommission / passengerCount) * 100) / 100;
    const driverEarnings = Math.round(amountAfterCommission * 100) / 100;

    return {
      passengerAmount,
      driverEarnings,
      platformFee: Math.round(platformFee * 100) / 100
    };
  }

  /**
   * Get payment statistics for user
   */
  static async getPaymentStats(userId: string, userRole: string) {
    try {
      const matchStage: any = {};

      if (userRole === 'rider') {
        matchStage.payerId = userId;
      } else if (userRole === 'driver') {
        matchStage.payeeId = userId;
      }

      const stats = await Payment.aggregate([
        { $match: matchStage },
        {
          $group: {
            _id: '$status',
            count: { $sum: 1 },
            totalAmount: { $sum: '$amount' }
          }
        }
      ]);

      return stats;
    } catch (error) {
      logger.error('Error getting payment stats:', error);
      throw error;
    }
  }
}
